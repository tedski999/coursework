Ted Johnson (TCD 19335618), 2021
Answer for question 3

1.

Instructions executed: 39
Clock cycles: 51
Result: 0x58

The reason these two numbers are not the same is due to issues occurring in
the processor pipeline, such as stall cycles.

To begin with, the pipeline starts empty. As such, the first 4 clock cycles
are simply fetching, decoding and executing the first instruction.

Additionally, 8 stall cycles are generated while executing this program.
- 4 stall cycles are generated due to instruction 0x1C requiring the result
  of load instruction 0x18. The processor must stall the pipeline as
  instruction 0x18 takes another clock cycle before the data is available for
  instruction 0x1C. These two instructions are executed 4 times, causing a
  total of 1*4=4 stall cycles.
- 1 stall cycle is generated due to a branch address calculation when
  jump instruction 0x24 is executed for the first time.
- 2 stall cycles are generated when conditional branch instruction 0x10 first
  succeeds and then fails during the next iteration.
- A final stall cycle is generated when conditional branch instruction 0x04
  first succeeds.

In total, this accounts for the 4+8=12 clock cycles where an instruction was
not executed.


2.

An easy way to generate an optimised but valid multiplication from the old
program is to add a NOP instruction after every branch and jump instruction,
and updating the branch and jump addresses accordingly. By doing this, the
program now halts after 60 clock cycles.

The increase in the number of clock cycles is due to every branch and jump
now requiring 2 clock cycles. Previously, a jump or branch may be predicted,
resulting in less clock cycles being required to execute it. With delayed
branch, every jump and branch takes two clock cycles. Without optimising
the use of delay slots, the program now takes an additional 9 clock cycles
to halt.


3.

There is a data dependency between instructions 0x18 and 0x1C which causes
stalling of the pipeline. We can remove this dependency to prevent stalling
of the pipeline by swapping instructions 0x1C and 0x20.

This reduces the number of clock cycles required for the program to halt
from 51 down to 47. This is because 4 stall cycles mentioned in part
1 of this question are no longer generated by the data dependency between
instructions 0x18 and 0x1C in the old program.
